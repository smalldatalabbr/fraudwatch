Perfeito. Com essas 3 infos dá pra fechar o **deploy V2 local com FastAPI** já casando com seu contrato atual (`models/` + `reports/decision_policy.json`) e com o schema exato das colunas.

Abaixo vai um **esqueleto completo**, pronto pra você copiar/colar.

---

## Estrutura recomendada (mínima e limpa)

```text
fraudwatch/
  app/
    main.py
    schemas.py
    dependencies.py
    decisioning.py
    inference.py
    logging.py
  src/
    paths.py
    utils.py
    decisioning/
      policy.py
  models/
    champion_lightgbm.pkl
  reports/
    decision_policy.json
  data/
    logs/
      inference.jsonl
  requirements.txt
```

---

## `src/decisioning/policy.py`

```python
from dataclasses import dataclass
from typing import Literal, Dict, Any

Decision = Literal["approve", "review", "block"]

@dataclass(frozen=True)
class DecisionPolicy:
    policy_name: str
    t1: float
    t2: float
    costs: Dict[str, float]
    rules: Dict[str, str]

    def apply(self, score: float) -> Decision:
        # Regra explícita (contrato operacional)
        if score < self.t1:
            return "approve"
        if score < self.t2:
            return "review"
        return "block"

    def as_dict(self) -> Dict[str, Any]:
        return {
            "policy_name": self.policy_name,
            "t1": self.t1,
            "t2": self.t2,
            "costs": self.costs,
            "rules": self.rules,
        }
```

---

## `app/schemas.py` (entrada/saída da API)

```python
from pydantic import BaseModel, Field
from typing import Literal, Dict, Any, List
from uuid import UUID

FEATURES_ORDER: List[str] = [
    "V1","V2","V3","V4","V5","V6","V7","V8","V9","V10",
    "V11","V12","V13","V14","V15","V16","V17","V18","V19","V20",
    "V21","V22","V23","V24","V25","V26","V27","V28","Amount"
]

Decision = Literal["approve", "review", "block"]

class ScoreRequest(BaseModel):
    V1: float
    V2: float
    V3: float
    V4: float
    V5: float
    V6: float
    V7: float
    V8: float
    V9: float
    V10: float
    V11: float
    V12: float
    V13: float
    V14: float
    V15: float
    V16: float
    V17: float
    V18: float
    V19: float
    V20: float
    V21: float
    V22: float
    V23: float
    V24: float
    V25: float
    V26: float
    V27: float
    V28: float
    Amount: float = Field(..., ge=0)

class ScoreResponse(BaseModel):
    event_id: UUID
    score: float
    decision: Decision
    thresholds: Dict[str, float]
    policy_name: str
    model_artifact: str
    # espaço pra evolução (sem quebrar contrato)
    meta: Dict[str, Any] = {}
```

---

## `app/dependencies.py` (carregamento de modelo e policy)

```python
import json
import joblib
from pathlib import Path
from typing import Tuple

from src.paths import MODELS_FOLDER, DECISION_POLICY
from src.decisioning.policy import DecisionPolicy

MODEL_ARTIFACT_NAME = "champion_lightgbm.pkl"

_model_cache = None
_policy_cache = None

def load_model():
    global _model_cache
    if _model_cache is None:
        model_path = MODELS_FOLDER / MODEL_ARTIFACT_NAME
        _model_cache = joblib.load(model_path)
    return _model_cache

def load_policy() -> DecisionPolicy:
    global _policy_cache
    if _policy_cache is None:
        with open(DECISION_POLICY, "r", encoding="utf-8") as f:
            raw = json.load(f)
        _policy_cache = DecisionPolicy(
            policy_name=raw["policy_name"],
            t1=float(raw["t1"]),
            t2=float(raw["t2"]),
            costs={k: float(v) for k, v in raw.get("costs", {}).items()},
            rules=raw.get("rules", {}),
        )
    return _policy_cache

def reload_policy() -> DecisionPolicy:
    global _policy_cache
    _policy_cache = None
    return load_policy()
```

---

## `app/inference.py` (score)

```python
import pandas as pd
from app.schemas import FEATURES_ORDER, ScoreRequest

def build_features(req: ScoreRequest) -> pd.DataFrame:
    row = req.model_dump()
    X = pd.DataFrame([row], columns=FEATURES_ORDER)
    return X

def predict_score(model, X) -> float:
    proba = model.predict_proba(X)[:, 1]
    return float(proba[0])
```

---

## `app/decisioning.py` (aplica policy)

```python
from src.decisioning.policy import DecisionPolicy

def decide(policy: DecisionPolicy, score: float) -> str:
    return policy.apply(score)
```

---

## `app/logging.py` (log JSONL)

```python
import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any

from src.utils import to_jsonable

LOG_PATH = Path("data/logs/inference.jsonl")

def write_event(event: Dict[str, Any]) -> None:
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)

    payload = {
        "ts": datetime.now(timezone.utc).isoformat(timespec="seconds"),
        **{k: to_jsonable(v) for k, v in event.items()},
    }
    with open(LOG_PATH, "a", encoding="utf-8") as f:
        f.write(json.dumps(payload, ensure_ascii=False) + "\n")
```

---

## `app/main.py` (FastAPI)

```python
from fastapi import FastAPI
from uuid import uuid4

from app.schemas import ScoreRequest, ScoreResponse
from app.dependencies import load_model, load_policy, reload_policy, MODEL_ARTIFACT_NAME
from app.inference import build_features, predict_score
from app.decisioning import decide
from app.logging import write_event

app = FastAPI(title="FraudWatch API", version="0.1.0")

@app.get("/health")
def health():
    model = load_model()
    policy = load_policy()
    return {
        "status": "ok",
        "model_loaded": model is not None,
        "policy_name": policy.policy_name,
        "t1": policy.t1,
        "t2": policy.t2,
    }

@app.post("/score", response_model=ScoreResponse)
def score(req: ScoreRequest):
    model = load_model()
    policy = load_policy()

    X = build_features(req)
    s = predict_score(model, X)
    d = decide(policy, s)

    event_id = uuid4()

    write_event({
        "event_id": str(event_id),
        "score": s,
        "decision": d,
        "thresholds": {"t1": policy.t1, "t2": policy.t2},
        "policy_name": policy.policy_name,
        "model_artifact": MODEL_ARTIFACT_NAME,
        "features": X.iloc[0].to_dict(),
    })

    return ScoreResponse(
        event_id=event_id,
        score=s,
        decision=d,
        thresholds={"t1": policy.t1, "t2": policy.t2},
        policy_name=policy.policy_name,
        model_artifact=MODEL_ARTIFACT_NAME,
        meta={"costs": policy.costs},
    )

@app.post("/policy/reload")
def policy_reload():
    policy = reload_policy()
    return {
        "status": "reloaded",
        "policy_name": policy.policy_name,
        "t1": policy.t1,
        "t2": policy.t2,
    }
```

---

## `requirements.txt` (mínimo)

```text
fastapi
uvicorn[standard]
pydantic
pandas
numpy
joblib
scikit-learn
lightgbm
```

---

## Como isso conecta com a V1.1 (contrato)

* O **modelo** só produz `score`.
* A **policy** regula *como o score vira ação*.
* No deploy você carrega ambos e aplica: **score → policy.apply(score) → decision**.
* Ao versionar `decision_policy.json` você consegue **mudar thresholds e custos sem retreinar** (que é exatamente o motivo do artefato existir).

---

## Próximo passo (pra você não travar)

Se você colar aqui o **conteúdo real do seu `src/utils.py`** (ou só confirmar que já colocou `to_jsonable` nele), eu adapto o `app/logging.py` para:

* salvar também em **Parquet/DuckDB** (melhor pra monitoramento),
* e já deixo um `jobs/monitor.py` calculando approve/review/block + PSI básico.

